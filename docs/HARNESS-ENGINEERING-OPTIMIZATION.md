# Harness Engineering Optimization Plan for Engram

**Based on**: [OpenAI's Harness Engineering methodology](https://openai.com/index/harness-engineering/)

**Date**: 2026-02-15

**Goal**: Transform Engram into a fully harness-optimized codebase where agents can reason about, modify, and improve the system autonomously.

---

## Executive Summary

OpenAI's Harness Engineering represents a paradigm shift: **the primary job of engineering becomes enabling agents to do useful work**. This means working depth-first ‚Äî breaking down larger goals into smaller building blocks (design, code, review, test), prompting agents to construct those blocks, and using them to unlock more complex tasks.

According to OpenAI's Harness Engineering post, OpenAI built an internal product over five months with **zero manually-written code** and reported approximately **one million lines across 1,500 pull requests**, all generated by Codex agents.

### Key Harness Engineering Principles

1. **Repository-Centered Context** ‚Äî Favor dependencies and abstractions that can be fully internalized and reasoned about in-repo
2. **Golden Principles** ‚Äî Encode opinionated, mechanical rules directly into the repository
3. **Recurring Cleanup Process** ‚Äî Background Codex tasks that scan for deviations, update quality grades, and open targeted refactoring PRs
4. **Technical Debt Management** ‚Äî Functions like garbage collection, keeping the codebase legible and consistent
5. **Depth-First Decomposition** ‚Äî Break larger goals into atomic building blocks

---

## Current State Analysis

### ‚úÖ What Engram Already Does Well

1. **Agent-Native Architecture** ‚úì
   - 69 atomic primitive tools (not workflow wrappers)
   - Tools compose into workflows via prompts
   - `query_raw` escape hatch for emergent capability

2. **Repository-Centered Context** ‚úì
   - All dependencies are internalized (Convex, Cohere, MCP SDK)
   - Boring, stable tech stack (TypeScript, Convex, Node.js)
   - Single source of truth (`tool-registry.ts`)

3. **Strong Documentation** ‚úì
   - `INSTITUTIONAL_LEARNINGS.md` captures patterns
   - Research synthesis ‚Üí implementation path clear
   - API reference auto-generated from code

4. **Automated Quality Processes** ‚úì
   - 14 Convex cron jobs (cleanup, decay, dedup, consolidate)
   - 6 Claude Code lifecycle hooks
   - Async enrichment pipeline

### ‚ùå What's Missing (Harness Engineering Gaps)

1. **No Golden Principles Document** ‚ùå
   - Rules are implicit, not encoded in-repo
   - No single source of truth for "how we do things"
   - Agents must infer patterns from code

2. **No Recurring Agent-Driven Cleanup** ‚ùå
   - Cron jobs are reactive (fix data)
   - No proactive code quality scanning
   - No automated refactoring PRs

3. **Limited Depth-First Task Decomposition** ‚ùå
   - Tasks are manually decomposed in plans
   - No structured task templates for agents
   - No task dependency graph

4. **Quality Metrics Not Tracked** ‚ùå
   - No code quality grades per file/module
   - No drift detection from golden principles
   - No automated quality reports

5. **Agent Performance Not Measured** ‚ùå
   - Memory operations tracked, but not agent effectiveness
   - No feedback loop for "which patterns worked"
   - No learning from successful completions

---

## Phase 1: Golden Principles Foundation

**Goal**: Encode all opinionated, mechanical rules directly into the repository as machine-readable golden principles.

### 1.1 Create `docs/GOLDEN-PRINCIPLES.md`

Document every "always do this, never do that" rule for Engram development:

```markdown
# Engram Golden Principles

## Code Organization

### GP-001: Single Source of Truth
**Rule**: All MCP tools MUST be defined in `mcp-server/src/lib/tool-registry.ts`
**Rationale**: Prevents drift between MCP server and plugin implementations
**Enforcement**: Automated via `scripts/validate-tool-registry.ts`

### GP-002: Convex Function Paths
**Rule**: All Convex function paths MUST use constants from `mcp-server/src/lib/convex-paths.ts`
**Rationale**: Type-safe references, prevents runtime errors from typos
**Enforcement**: TypeScript compiler + grep validation

### GP-003: Atomic Primitives Only
**Rule**: MCP tools MUST be atomic operations, not workflow wrappers
**Rationale**: Agents compose workflows via prompts, not code
**Enforcement**: Manual code review + 50-line tool size limit

## Logging & Debugging

### GP-004: MCP Server Logging Constraint
**Rule**: MCP server MUST NEVER write to stdout (use stderr only)
**Rationale**: stdout is reserved for JSON-RPC protocol
**Enforcement**: Automated grep scan for console.log

### GP-005: Structured Logging
**Rule**: All logs MUST use structured format: `[component] message`
**Rationale**: Enables automated log parsing and analysis
**Enforcement**: Linter rule + automated validation

## Data Modeling

### GP-006: Scope-Based Access Control
**Rule**: Every fact MUST have a scopeId reference
**Rationale**: Multi-agent memory isolation
**Enforcement**: Convex schema validation

### GP-007: Async Enrichment Pattern
**Rule**: Facts MUST be stored immediately, enrichment runs async
**Rationale**: <50ms latency for memory_store_fact
**Enforcement**: Performance tests + monitoring

## Documentation

### GP-008: API Reference Auto-Generation
**Rule**: API reference MUST be generated from tool-registry.ts, never written manually
**Rationale**: Documentation always matches implementation
**Enforcement**: CI check that docs/API-REFERENCE.md is up-to-date

### GP-009: Institutional Learnings
**Rule**: Every gotcha/lesson MUST be documented in INSTITUTIONAL_LEARNINGS.md
**Rationale**: Prevents repeating mistakes
**Enforcement**: PR template checklist item
```

### 1.2 Create Validation Scripts

**Script 1: `scripts/validate-golden-principles.ts`**
```typescript
// Scans codebase for violations of golden principles
// Returns: quality grade (A-F) per file + list of violations

export async function validateGoldenPrinciples() {
  const violations = [];

  // GP-004: Check for console.log in MCP server
  const stdoutLogs = await grep('console.log', 'mcp-server/src/**/*.ts');
  if (stdoutLogs.length > 0) {
    violations.push({
      principle: 'GP-004',
      severity: 'critical',
      files: stdoutLogs,
      message: 'MCP server must not write to stdout'
    });
  }

  // GP-001: Verify all tools in registry
  const toolsInCode = await extractToolsFromCode();
  const toolsInRegistry = await extractToolsFromRegistry();
  const drift = difference(toolsInCode, toolsInRegistry);
  if (drift.length > 0) {
    violations.push({
      principle: 'GP-001',
      severity: 'high',
      files: drift,
      message: 'Tools exist outside tool-registry.ts'
    });
  }

  return { violations, grade: calculateGrade(violations) };
}
```

**Script 2: `scripts/generate-quality-report.ts`**
```typescript
// Generates per-file quality grades based on golden principles
// Output: docs/QUALITY-REPORT.md (auto-updated via cron)

export async function generateQualityReport() {
  const files = await glob('**/*.ts');
  const grades = await Promise.all(
    files.map(async (file) => {
      const violations = await checkFile(file);
      return {
        file,
        grade: calculateGrade(violations),
        violations,
        lastChecked: Date.now()
      };
    })
  );

  await writeReport('docs/QUALITY-REPORT.md', grades);
}
```

### 1.3 Add Pre-Commit Hook

```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "Running golden principles validation..."
npx tsx scripts/validate-golden-principles.ts

if [ $? -ne 0 ]; then
  echo "‚ùå Golden principles violations detected. Fix before committing."
  exit 1
fi
```

---

## Phase 2: Recurring Agent-Driven Cleanup

**Goal**: Background Codex agents that scan for deviations, update quality grades, and open targeted refactoring PRs.

### 2.1 Create Cleanup Agent System

**New directory**: `agents/cleanup/`

```
agents/cleanup/
‚îú‚îÄ‚îÄ drift-detector.ts      # Scans for violations of golden principles
‚îú‚îÄ‚îÄ refactor-suggester.ts  # Generates PR descriptions for fixes
‚îú‚îÄ‚îÄ quality-updater.ts     # Updates QUALITY-REPORT.md
‚îî‚îÄ‚îÄ scheduled-cleanup.ts   # Cron job orchestrator
```

### 2.2 Implement Drift Detection Agent

**File**: `agents/cleanup/drift-detector.ts`

```typescript
import { validateGoldenPrinciples } from '../../scripts/validate-golden-principles';
import { openGitHubPR } from '../lib/github';

export async function detectAndFixDrift() {
  const { violations } = await validateGoldenPrinciples();

  for (const violation of violations.filter(v => v.severity === 'critical')) {
    // Generate fix
    const fix = await generateFix(violation);

    // Create branch
    await git.checkout(`fix/${violation.principle.toLowerCase()}`);

    // Apply fix
    await applyFix(fix);

    // Open PR
    await openGitHubPR({
      title: `ü§ñ Fix ${violation.principle}: ${violation.message}`,
      body: `
## Automated Cleanup

**Golden Principle**: ${violation.principle}
**Violation**: ${violation.message}

### Changes
${fix.description}

### Verification
- [x] Golden principles validation passes
- [x] All tests pass
- [x] Quality grade improved

This PR was generated automatically by the drift-detector agent.
Review time: <1 minute expected.
      `,
      labels: ['automated-cleanup', 'harness-engineering']
    });
  }
}
```

### 2.3 Add Convex Cron for Quality Monitoring

**File**: `convex/crons.ts`

```typescript
// Add new cron job
crons.weekly(
  "harness-engineering-cleanup",
  { hourUTC: 6, minuteUTC: 0, dayOfWeek: "monday" },
  internal.crons.harnessEngineeringCleanup
);
```

**File**: `convex/crons/harness-engineering-cleanup.ts`

```typescript
export const harnessEngineeringCleanup = internalAction({
  handler: async (ctx) => {
    // 1. Run golden principles validation
    const validation = await runValidation();

    // 2. Generate quality report
    const report = await generateQualityReport();

    // 3. Open PRs for critical violations
    const prs = await openCleanupPRs(validation.violations);

    // 4. Notify via Engram memory
    await ctx.runMutation(internal.functions.storeFact, {
      content: `Harness Engineering Cleanup: ${prs.length} PRs opened, quality grade: ${report.averageGrade}`,
      factType: 'system_maintenance',
      agentId: 'harness-cleanup-agent',
      scopeId: 'system-wide'
    });

    return { prs, report };
  }
});
```

---

## Phase 3: Depth-First Task Templates

**Goal**: Structured task decomposition templates that agents can instantiate for common workflows.

### 3.1 Create Task Template System

**New directory**: `docs/task-templates/`

```
docs/task-templates/
‚îú‚îÄ‚îÄ README.md                      # How to use templates
‚îú‚îÄ‚îÄ new-mcp-tool.md               # Template for adding a new MCP tool
‚îú‚îÄ‚îÄ convex-table.md               # Template for adding a Convex table
‚îú‚îÄ‚îÄ cron-job.md                   # Template for adding a cron job
‚îú‚îÄ‚îÄ lifecycle-hook.md             # Template for adding a Claude Code hook
‚îî‚îÄ‚îÄ feature-implementation.md     # Generic feature template
```

### 3.2 Example Template: New MCP Tool

**File**: `docs/task-templates/new-mcp-tool.md`

```markdown
# Task Template: Add New MCP Tool

## Prerequisites
- [ ] Read `docs/GOLDEN-PRINCIPLES.md`
- [ ] Understand tool-registry pattern from `mcp-server/src/lib/tool-registry.ts`
- [ ] Review similar tools for naming conventions

## Task Breakdown (Depth-First)

### 1. Design Phase
- [ ] 1.1 Define tool purpose (single atomic operation)
- [ ] 1.2 Define input schema (Zod)
- [ ] 1.3 Define output format
- [ ] 1.4 Identify which Convex functions to call
- [ ] 1.5 Determine error handling strategy

### 2. Implementation Phase
- [ ] 2.1 Add Zod schema to `tool-registry.ts`
- [ ] 2.2 Implement handler function in `mcp-server/src/tools/`
- [ ] 2.3 Register in `TOOL_REGISTRY` array
- [ ] 2.4 Add to category exports in `tool-registry.ts`
- [ ] 2.5 Verify TypeScript compiles

### 3. Testing Phase
- [ ] 3.1 Add unit test in `mcp-server/src/tools/__tests__/`
- [ ] 3.2 Add integration test with Convex backend
- [ ] 3.3 Test via MCPorter CLI: `npx mcporter call engram.memory_new_tool`
- [ ] 3.4 Verify tool shows in `npx mcporter list engram`

### 4. Documentation Phase
- [ ] 4.1 Run `npx tsx scripts/generate-api-reference.ts`
- [ ] 4.2 Verify tool appears in `docs/API-REFERENCE.md`
- [ ] 4.3 Add usage example to `docs/USAGE-EXAMPLES.md`
- [ ] 4.4 Update tool count in `README.md` (currently 69)

### 5. Validation Phase
- [ ] 5.1 Run `npx tsx scripts/validate-golden-principles.ts`
- [ ] 5.2 Verify no new violations introduced
- [ ] 5.3 Check quality grade for modified files
- [ ] 5.4 Run full test suite

### 6. PR Phase
- [ ] 6.1 Create branch: `feat/mcp-tool-{name}`
- [ ] 6.2 Commit with message: `feat(mcp): add memory_{name} tool`
- [ ] 6.3 Open PR with template checklist
- [ ] 6.4 Tag with `mcp-tools` and `harness-engineering`

## Estimated Time
- Design: 15 minutes
- Implementation: 30 minutes
- Testing: 20 minutes
- Documentation: 10 minutes
- Validation: 5 minutes
- **Total: ~80 minutes**

## Quality Checklist
- [ ] Tool is atomic (single operation)
- [ ] Follows GP-001 (registered in tool-registry.ts)
- [ ] Follows GP-004 (no stdout logging)
- [ ] Follows GP-008 (docs auto-generated)
- [ ] Zero TypeScript errors
- [ ] All tests pass
```

### 3.3 Agent Integration

Agents should be able to instantiate templates:

```typescript
// agents/lib/task-instantiator.ts
export async function instantiateTemplate(
  templateName: string,
  params: Record<string, string>
) {
  const template = await readTemplate(templateName);
  const tasks = parseTasksFromTemplate(template);

  // Replace placeholders with params
  const instantiated = tasks.map(task =>
    substituteParams(task, params)
  );

  // Create task graph with dependencies
  return createTaskGraph(instantiated);
}

// Usage:
const tasks = await instantiateTemplate('new-mcp-tool', {
  name: 'prune_stale_facts',
  category: 'lifecycle',
  convex_function: 'pruneStale'
});
```

---

## Phase 4: Quality Metrics & Tracking

**Goal**: Track code quality grades per file/module, detect drift from golden principles, generate automated quality reports.

### 4.1 Quality Grade System

**Grading Criteria:**

| Grade | Violations | Description |
|-------|-----------|-------------|
| A | 0 critical, 0 high | Perfect adherence to golden principles |
| B | 0 critical, 1-2 high | Minor deviations, easily fixed |
| C | 0 critical, 3-5 high | Moderate drift, requires refactoring |
| D | 1 critical, any high | Critical violation, must fix immediately |
| F | 2+ critical | Multiple critical violations, urgent |

### 4.2 Quality Dashboard

**New file**: `docs/QUALITY-DASHBOARD.md` (auto-generated)

```markdown
# Engram Code Quality Dashboard

**Last Updated**: 2026-02-15T10:30:00Z
**Overall Grade**: A-

## Summary
- Total files: 247
- Grade A: 213 (86%)
- Grade B: 28 (11%)
- Grade C: 6 (2%)
- Grade D: 0 (0%)
- Grade F: 0 (0%)

## Critical Violations (Immediate Action Required)
None detected ‚úì

## High-Priority Violations
1. `mcp-server/src/tools/legacy-tool.ts` - Grade C
   - GP-001: Not registered in tool-registry.ts
   - GP-003: 157 lines (exceeds 50-line limit)
   - **Action**: Refactor into atomic primitives

## Module Quality Breakdown

### MCP Server (mcp-server/src/)
- **Overall Grade**: A
- Files: 42
- Average grade: A-
- Trend: ‚Üë (improved from B+ last week)

### Convex Backend (convex/)
- **Overall Grade**: A
- Files: 87
- Average grade: A
- Trend: ‚Üí (stable)

### CLI (cli/src/)
- **Overall Grade**: B+
- Files: 23
- Average grade: B+
- Trend: ‚Üë (improved from B last week)

## Recent Improvements
1. Fixed GP-004 violations in 12 files (console.log ‚Üí console.error)
2. Refactored `memory_get_context` into 7 atomic primitives
3. Updated all Convex paths to use type-safe constants

## Recommended Actions
1. üî¥ Urgent: Refactor `legacy-tool.ts` (Grade C)
2. üü° This week: Improve CLI module to Grade A (add missing tests)
3. üü¢ Next sprint: Add integration tests for new primitives
```

### 4.3 CI/CD Integration

**GitHub Actions**: `.github/workflows/quality-check.yml`

```yaml
name: Quality Check

on:
  pull_request:
  schedule:
    - cron: '0 6 * * 1'  # Weekly on Monday 6am UTC

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate Golden Principles
        run: npx tsx scripts/validate-golden-principles.ts

      - name: Generate Quality Report
        run: npx tsx scripts/generate-quality-report.ts

      - name: Check for Regressions
        run: |
          # Fail if any file grade dropped
          npx tsx scripts/check-quality-regression.ts

      - name: Post PR Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const report = require('./docs/QUALITY-REPORT.md');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              body: `## Quality Check Results\n\n${report}`
            });
```

---

## Phase 5: Agent Performance Feedback Loop

**Goal**: Measure which patterns lead to successful agent completions, learn from outcomes, feed back into golden principles.

### 5.1 Agent Performance Schema

**Add to `convex/schema.ts`:**

```typescript
agent_performance: defineTable({
  agentId: v.string(),
  taskType: v.string(), // 'mcp-tool-creation' | 'refactoring' | 'bug-fix'
  startTime: v.number(),
  endTime: v.number(),
  success: v.boolean(),

  // Metrics
  linesChanged: v.number(),
  testsAdded: v.number(),
  violations: v.array(v.string()), // Golden principle violations introduced
  qualityGradeBefore: v.string(),
  qualityGradeAfter: v.string(),

  // Patterns used
  templateUsed: v.optional(v.string()),
  patternsFollowed: v.array(v.string()),
  patternsViolated: v.array(v.string()),

  // Outcome
  mergedAt: v.optional(v.number()),
  reviewTime: v.optional(v.number()),
  rollbackRequired: v.boolean(),

  // Learning signals
  wasHelpful: v.optional(v.boolean()), // Manual feedback
  reusedCount: v.number(), // How many times pattern was copied
})
  .index("by_agent", ["agentId", "startTime"])
  .index("by_task_type", ["taskType", "success"])
  .index("by_success", ["success", "endTime"]);
```

### 5.2 Performance Tracking Hook

**New hook**: `.claude/hooks/track-agent-performance.sh`

```bash
#!/bin/bash
# Track agent performance for every task completion

TASK_TYPE="$1"
SUCCESS="$2"
METRICS_JSON="$3"

npx tsx scripts/track-agent-performance.ts \
  --agent-id "$ENGRAM_AGENT_ID" \
  --task-type "$TASK_TYPE" \
  --success "$SUCCESS" \
  --metrics "$METRICS_JSON"
```

### 5.3 Learning Analysis Agent

**File**: `agents/learning/pattern-analyzer.ts`

```typescript
export async function analyzeSuccessfulPatterns() {
  // Query high-success tasks
  const successful = await convex.query(
    api.functions.getAgentPerformance,
    { success: true, minReusedCount: 5 }
  );

  // Extract common patterns
  const patterns = extractPatterns(successful);

  // Generate insights
  const insights = patterns.map(pattern => ({
    pattern: pattern.name,
    successRate: pattern.successRate,
    avgReviewTime: pattern.avgReviewTime,
    recommendation: pattern.successRate > 0.9
      ? 'Promote to Golden Principle'
      : 'Continue monitoring'
  }));

  // Write to learning doc
  await updateLearningDoc('docs/PATTERN-INSIGHTS.md', insights);

  // Suggest golden principles updates
  const newPrinciples = insights
    .filter(i => i.recommendation === 'Promote to Golden Principle')
    .map(i => suggestGoldenPrinciple(i));

  return { insights, newPrinciples };
}
```

### 5.4 Automated Golden Principles Updates

**Cron**: Weekly analysis that suggests new golden principles based on agent performance data

```typescript
// convex/crons/update-golden-principles.ts
export const updateGoldenPrinciples = internalAction({
  handler: async (ctx) => {
    const analysis = await analyzeSuccessfulPatterns();

    if (analysis.newPrinciples.length > 0) {
      // Create PR to update GOLDEN-PRINCIPLES.md
      await openGitHubPR({
        title: 'üß† Update Golden Principles (Agent Learning)',
        body: `
## New Golden Principles from Agent Performance Analysis

${analysis.newPrinciples.map(p => `
### ${p.id}: ${p.title}
**Success Rate**: ${p.successRate}%
**Avg Review Time**: ${p.avgReviewTime}min
**Pattern**: ${p.pattern}

**Recommendation**: ${p.recommendation}
`).join('\n')}

This PR was generated automatically from analysis of ${analysis.totalTasks} completed tasks.
        `,
        files: {
          'docs/GOLDEN-PRINCIPLES.md': generateUpdatedPrinciples(analysis)
        },
        labels: ['golden-principles', 'agent-learning']
      });
    }
  }
});
```

---

## Implementation Roadmap

### Week 1: Golden Principles Foundation
- [ ] Day 1: Create `docs/GOLDEN-PRINCIPLES.md`
- [ ] Day 2: Implement `validate-golden-principles.ts`
- [ ] Day 3: Implement `generate-quality-report.ts`
- [ ] Day 4: Add pre-commit hook
- [ ] Day 5: Run validation, fix all critical violations

### Week 2: Recurring Agent Cleanup
- [ ] Day 1: Create `agents/cleanup/` structure
- [ ] Day 2: Implement drift-detector agent
- [ ] Day 3: Implement refactor-suggester agent
- [ ] Day 4: Add Convex cron for weekly cleanup
- [ ] Day 5: Test automated PR creation

### Week 3: Task Templates
- [ ] Day 1: Create `docs/task-templates/` structure
- [ ] Day 2: Write 5 core templates
- [ ] Day 3: Implement task-instantiator
- [ ] Day 4: Test template-driven development
- [ ] Day 5: Document template system

### Week 4: Quality Metrics
- [ ] Day 1: Implement quality grading system
- [ ] Day 2: Generate QUALITY-DASHBOARD.md
- [ ] Day 3: Add GitHub Actions integration
- [ ] Day 4: Create quality regression checks
- [ ] Day 5: Monitor and tune thresholds

### Week 5: Performance Feedback
- [ ] Day 1: Add agent_performance table
- [ ] Day 2: Implement performance tracking hook
- [ ] Day 3: Create pattern-analyzer agent
- [ ] Day 4: Add automated golden principles updates
- [ ] Day 5: Full system integration test

---

## Success Metrics

### Quantitative

1. **Code Quality**
   - Target: 95%+ of files grade A or B
   - Baseline: TBD (run initial validation)

2. **Automated Cleanup**
   - Target: 10+ automated PRs per month
   - Target: <5 minute avg review time per PR

3. **Agent Velocity**
   - Target: 50% reduction in time to add new MCP tool
   - Target: 80% of new features use task templates

4. **Technical Debt**
   - Target: Zero critical violations for 30+ consecutive days
   - Target: Golden principles violations trend down 20% per quarter

### Qualitative

1. **Agent Autonomy**
   - Agents can add new features without human design phase
   - Agents can refactor code based on golden principles
   - Agents can learn from successful patterns

2. **Codebase Legibility**
   - New contributors can understand patterns in <1 hour
   - Documentation always matches implementation
   - Violations are caught before merge

3. **Continuous Improvement**
   - Golden principles evolve based on learnings
   - Quality trends improve over time
   - Agent performance improves iteratively

---

## Long-Term Vision

### 6 Months
- Engram codebase is fully agent-maintained
- Zero manual code review for routine changes
- Golden principles auto-update from learnings

### 12 Months
- 90%+ of new features built via templates
- Agents autonomously propose architecture improvements
- Quality dashboard shows consistent A grades

### 24 Months
- Engram becomes reference implementation for harness engineering
- Template system exported as reusable framework
- Agent learning corpus powers next-generation tools

---

## References

- [Harness Engineering: Leveraging Codex in an Agent-First World](https://openai.com/index/harness-engineering/)
- [Unlocking the Codex Harness: How We Built the App Server](https://openai.com/index/unlocking-the-codex-harness/)
- [2025 Was Agents. 2026 Is Agent Harnesses](https://aakashgupta.medium.com/2025-was-agents-2026-is-agent-harnesses-heres-why-that-changes-everything-073e9877655e)
- [Codex for Agent-First Engineering: Practical Ways to Win](https://www.gend.co/blog/codex-agent-first-engineering)

---

## Next Steps

1. **Immediate**: Review this plan with team
2. **This week**: Implement Phase 1 (Golden Principles)
3. **This month**: Complete Phases 1-3 (Foundation + Cleanup + Templates)
4. **This quarter**: Full implementation of all 5 phases

**Champion**: Assign an owner for each phase
**Timeline**: 5 weeks to full implementation
**Budget**: Zero additional infrastructure cost (all automated agents)
