{"id":"engram-u51","title":"Engram Phase 1: Foundation — Convex Backend Setup","description":"# Engram Phase 1: Foundation\n\n## Background\nEngram is a unified multi-agent memory system for OpenClaw agents. It provides a shared memory layer where agents store atomic facts, recall context via semantic search, and share knowledge across devices and sessions. Local-first via LanceDB, cloud-synced through Convex, multimodal embeddings via Cohere Embed 4.\n\n## What This Epic Covers\nPhase 1 establishes the foundational data layer in Convex that every subsequent phase builds on:\n- Initialize Convex project\n- Deploy full 10-table schema (all optional future-phase fields included)\n- Implement CRUD mutations/queries for all 10 tables\n- Full-text search on facts with scope/type/agent filtering\n- Scope-based write permission enforcement on storeFact\n- Seed script to populate initial entities and default scopes\n\n## Why Full Schema From Day 1\nThe repo-research agent identified 17 schema discrepancies between PLAN.md (full) and the detailed plan (simplified). Decision: deploy PLAN.md's full schema with all future-phase fields as v.optional(). Convex schema changes require migrations; adding fields later is friction. Optional fields cost nothing until populated. Deploy once, never migrate schema.\n\n## Key Technical Decisions (Locked)\n- Backend: Convex (realtime, native vector search, scheduled functions, free tier)\n- Embeddings: Cohere Embed 4 (1024-dim, multimodal) — NOT OpenAI\n- MCP SDK: @modelcontextprotocol/sdk v1.x (Phase 2, not Phase 1)\n- Access control: Scope-based (NOT per-fact ACLs)\n- Memory lifecycle: 5-state machine (active → dormant → merged → archived → pruned)\n- Decay: Differential by fact type + emotional weight\n- Use lifecycleState (5 states) NOT status (3 states)\n\n## Phase 1 Scope Boundary\nIN SCOPE: Convex project init, schema, CRUD, full-text search, seed script, write permissions\nOUT OF SCOPE: MCP server (Phase 2), embeddings/enrichment (Phase 3), multi-agent (Phase 4), LanceDB sync (Phase 5), migration (Phase 6)\n\n## Success Criteria\n- npx convex dev runs successfully with all 10 tables visible in dashboard\n- Can insert a fact via storeFact mutation with scope write permission check\n- Full-text search on facts.content returns results filtered by scopeId, factType, createdBy\n- All 10 tables have basic CRUD operations\n- Seed script populates initial entities and default scopes\n- Write to scope with writePolicy: \"members\" fails for non-members\n- TypeScript strict mode, no any types in function args/returns\n\n## References\n- PLAN.md — Full schema (lines 89-289), Phase 1 checklist (lines 490-496)\n- docs/plans/2026-02-11-feat-engram-phase1-foundation-plan.md — Detailed Phase 1 plan\n- docs/research/tech-stack-best-practices.md — Convex patterns (1297 lines)\n- docs/INSTITUTIONAL_LEARNINGS.md — 8 critical implementation patterns","status":"open","priority":0,"issue_type":"epic","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:03:49.903178+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:03:49.903178+01:00"}
{"id":"engram-u51.1","title":"Initialize Convex project","description":"# Initialize Convex Project\n\n## What\nRun npx create-convex in the Engram repo root to set up the Convex backend project. This creates the convex/ directory structure that all subsequent tasks depend on.\n\n## Why\nConvex is the cloud backend for Engram. It provides the schema DSL (defineSchema, defineTable, v validators), the function runtime (query, mutation, action), native vector search, scheduled functions (crons), and the ConvexHttpClient for external access. Without this initialization, no other Phase 1 work can proceed.\n\n## Steps\n1. Run npx create-convex in /Volumes/Main SSD/Developer/engram\n2. Select \"create a new project\" when prompted\n3. Verify convex/ directory created with:\n   - _generated/ (auto-generated types — commit per Convex best practices)\n   - tsconfig.json (Convex-specific TypeScript config)\n4. Verify root package.json updated with convex dependency (^1.17.0)\n5. Run npx convex dev to confirm project compiles with empty schema\n6. Update .gitignore if needed (Convex may add entries; convex/_generated/ should be committed)\n\n## Technical Notes\n- The current package.json only has beautiful-mermaid as dependency\n- Node.js 22+ and TypeScript 5.7+ are prerequisites\n- Convex free tier is sufficient for development\n- Environment variable CONVEX_URL will be obtained from this step\n\n## Acceptance Criteria\n- [ ] convex/ directory exists with _generated/ and tsconfig.json\n- [ ] package.json has convex ^1.17.0 in dependencies\n- [ ] npx convex dev compiles without errors (empty schema OK)\n- [ ] CONVEX_URL environment variable available (from .env.local or Convex dashboard)\n\n## Gotchas\n- npx create-convex may prompt for auth — need Convex account (free tier)\n- The generated convex/_generated/ directory SHOULD be committed (Convex convention)\n- Existing .gitignore already has .env and .env.local entries (good)\n\n## Estimate\n15 minutes","status":"closed","priority":0,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:04:07.072193+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:05.646734+01:00","closed_at":"2026-02-11T22:25:05.646755+01:00","dependencies":[{"issue_id":"engram-u51.1","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:04:07.074429+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.10","title":"Implement themes CRUD for hierarchical memory","description":"# Implement Themes CRUD\n\n## What\nCreate convex/functions/themes.ts for the themes table. Themes are thematic clusters of related facts — the EverMemOS MemScenes pattern for hierarchical memory.\n\n## Why\nThemes provide a higher-level view of memory. Instead of searching through hundreds of individual facts, agents can retrieve theme summaries. The weekly consolidation cron (Phase 6) will automatically group related facts into themes. Themes have their own embeddings for vector search.\n\n## Schema (from PLAN.md)\n- name: string\n- description: string\n- factIds: Id\u003c\"facts\"\u003e[] (facts in this theme)\n- entityIds: Id\u003c\"entities\"\u003e[] (related entities)\n- scopeId: Id\u003c\"memory_scopes\"\u003e\n- importance: float64\n- lastUpdated: number\n- embedding: float64[]? (1024-dim, for vector search on themes)\n\n## Functions to Implement\n\n### Mutations\n1. create(name, description, factIds, entityIds, scopeId, importance?)\n2. update(themeId, description?, factIds?, entityIds?, importance?)\n   - Update lastUpdated to Date.now()\n3. addFact(themeId, factId) — append to factIds (convenience)\n\n### Queries\n4. get(themeId)\n5. getByScope(scopeId, limit?) — using by_scope index\n6. searchThemes(query) — could use a searchIndex if added, or filter by name\n\n## Acceptance Criteria\n- [ ] Can create themes linked to scopes, facts, and entities\n- [ ] Can update theme description and add facts\n- [ ] getByScope returns themes for a given scope\n\n## Estimate\n20 minutes","status":"closed","priority":2,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:06:52.954648+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:07.618047+01:00","closed_at":"2026-02-11T22:25:07.61805+01:00","dependencies":[{"issue_id":"engram-u51.10","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:06:52.955901+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.10","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:06:52.957741+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.11","title":"Implement sync_log CRUD for LanceDB sync tracking","description":"# Implement Sync Log CRUD\n\n## What\nCreate convex/functions/sync.ts for the sync_log table. Tracks per-node LanceDB sync status for Phase 5.\n\n## Why\nEach device (Mac Mini, MacBook Air, MacBook Pro) runs its own LanceDB instance. The sync_log tracks what each node has synced, enabling differential sync (only pull facts since last sync). Phase 1 creates the CRUD; Phase 5 will use it for the actual sync daemon.\n\n## Schema (from PLAN.md)\n- nodeId: string — device identifier\n- lastSyncTimestamp: number — when this node last synced\n- factsSynced: number — total facts synced to this node\n- status: string — ok|error|syncing\n\n## Functions to Implement\n\n### Mutations\n1. updateSyncLog(nodeId, lastSyncTimestamp, factsSynced, status)\n   - Upsert by nodeId (create or update)\n\n### Queries\n2. getSyncStatus(nodeId) — using by_node index\n3. getFactsSince(timestamp, scopeId?) — internalQuery\n   - Return facts created/updated after timestamp\n   - Filter by scope if provided\n   - Used by sync daemon in Phase 5\n\n## Acceptance Criteria\n- [ ] Can create/update sync log entries\n- [ ] getSyncStatus returns correct status for a node\n- [ ] getFactsSince returns facts after a given timestamp\n\n## Estimate\n15 minutes","status":"closed","priority":2,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:07:04.289418+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:07.810836+01:00","closed_at":"2026-02-11T22:25:07.810844+01:00","dependencies":[{"issue_id":"engram-u51.11","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:07:04.290514+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.11","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:07:04.29189+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.12","title":"Write seed script to populate initial entities and scopes","description":"# Write Seed Script\n\n## What\nCreate scripts/seed.ts to populate the Convex database with initial entities, default scopes, and sample facts. Uses ConvexHttpClient to call mutations from outside the Convex runtime.\n\n## Why\nThe seed script bootstraps Engram with a useful starting state:\n- Default scopes (global, private-indy) for immediate use\n- Core entities (Ryan, Indy, OpenClaw, Engram, Convex, LanceDB, Cohere) with relationships\n- Sample facts to verify full-text search and CRUD work end-to-end\n- Provides a repeatable setup for development and testing\n\n## Seed Data\n\n### Default Scopes\n1. global — readPolicy: \"all\", writePolicy: \"all\", description: \"Shared knowledge base accessible to all agents\"\n2. private-indy — readPolicy: \"members\", writePolicy: \"members\", members: [\"indy\"], description: \"Indy's private memory space\"\n\n### Initial Entities\n| entityId | name | type | relationships |\n|----------|------|------|---------------|\n| entity-ryan | Ryan | person | created_by: entity-openclaw, works_with: entity-indy |\n| entity-indy | Indy | person | works_with: entity-ryan, part_of: entity-openclaw |\n| entity-openclaw | OpenClaw | project | created_by: entity-ryan |\n| entity-engram | Engram | project | part_of: entity-openclaw, depends_on: entity-convex, depends_on: entity-lancedb |\n| entity-convex | Convex | tool | related_to: entity-engram |\n| entity-lancedb | LanceDB | tool | related_to: entity-engram |\n| entity-cohere | Cohere | tool | related_to: entity-engram |\n\n### Sample Facts (3-5 facts for testing)\n- \"Engram uses Cohere Embed 4 for 1024-dim multimodal embeddings\" (factType: decision, scope: global)\n- \"Convex vector search is only available in actions, not queries\" (factType: learning, scope: global)\n- \"Ryan is the creator of OpenClaw and its agent ecosystem\" (factType: observation, scope: global)\n\n## Implementation Pattern\n\n```typescript\n// scripts/seed.ts\nimport { ConvexHttpClient } from \"convex/browser\";\nimport { api } from \"../convex/_generated/api\";\n\nconst client = new ConvexHttpClient(process.env.CONVEX_URL!);\n\nasync function seed() {\n  console.error(\"[seed] Starting...\");\n\n  // 1. Create scopes first (facts need scopeIds)\n  const globalScope = await client.mutation(api.functions.scopes.createScope, {\n    name: \"global\",\n    description: \"Shared knowledge base\",\n    members: [\"indy\"],\n    readPolicy: \"all\",\n    writePolicy: \"all\",\n  });\n\n  // 2. Register agent\n  await client.mutation(api.functions.agents.register, {\n    agentId: \"indy\",\n    name: \"Indy\",\n    capabilities: [\"memory\", \"code\", \"research\"],\n    defaultScope: \"private\",\n  });\n\n  // 3. Create entities\n  for (const entity of entities) {\n    await client.mutation(api.functions.entities.upsert, entity);\n  }\n\n  // 4. Store sample facts\n  for (const fact of sampleFacts) {\n    await client.mutation(api.functions.facts.storeFact, {\n      ...fact,\n      scopeId: globalScope,\n      createdBy: \"indy\",\n    });\n  }\n\n  console.error(\"[seed] Done!\");\n}\n\nseed().catch(console.error);\n```\n\n## Technical Notes\n- Use ConvexHttpClient (not internal functions) — seed runs OUTSIDE Convex runtime\n- Use console.error for all logging (stdout hygiene habit from MCP patterns)\n- Use process.env.CONVEX_URL for Convex connection\n- Run with: npx tsx scripts/seed.ts (or npx convex run scripts/seed if using Convex runner)\n- Batch pattern: Could use a single batch mutation for entities, but individual calls are fine for seed data (~10 items)\n- Make idempotent: upsert for entities, check-before-create for scopes\n\n## Acceptance Criteria\n- [ ] scripts/seed.ts exists and runs without errors\n- [ ] Creates global and private-indy scopes\n- [ ] Creates 7 initial entities with relationships\n- [ ] Stores 3+ sample facts in global scope\n- [ ] Facts are searchable via full-text search after seeding\n- [ ] Script is idempotent (running twice doesn't create duplicates)\n- [ ] All logging goes to stderr\n\n## Estimate\n30 minutes","status":"closed","priority":1,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:07:29.875278+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:07.967342+01:00","closed_at":"2026-02-11T22:25:07.967345+01:00","dependencies":[{"issue_id":"engram-u51.12","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:07:29.876065+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.12","depends_on_id":"engram-u51.3","type":"blocks","created_at":"2026-02-11T22:07:29.877179+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.12","depends_on_id":"engram-u51.4","type":"blocks","created_at":"2026-02-11T22:07:29.878235+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.12","depends_on_id":"engram-u51.5","type":"blocks","created_at":"2026-02-11T22:07:29.879421+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.12","depends_on_id":"engram-u51.6","type":"blocks","created_at":"2026-02-11T22:07:29.882011+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.13","title":"End-to-end verification and testing","description":"# End-to-End Verification\n\n## What\nVerify that all Phase 1 deliverables work correctly together. This is the final quality gate before Phase 2 can begin.\n\n## Why\nPhase 2 (MCP Server) depends entirely on Phase 1's Convex functions working correctly. Every MCP tool call ultimately hits a Convex mutation or query. If the foundation is broken, everything built on it will be broken.\n\n## Verification Checklist\n\n### Schema Verification\n- [ ] npx convex dev compiles without errors\n- [ ] Convex dashboard shows all 10 tables: facts, entities, conversations, sessions, agents, memory_scopes, signals, themes, sync_log\n- [ ] Each table has correct indexes visible in dashboard\n- [ ] vector_search index defined on facts (dimensions: 1024)\n- [ ] theme_search index defined on themes (dimensions: 1024)\n\n### CRUD Round-Trip Tests (via Convex dashboard or convex functions CLI)\n- [ ] Create scope → query scope → add member → verify\n- [ ] Register agent → query agent → update lastSeen → verify\n- [ ] Store fact (with scope write check) → get fact by ID → verify all fields\n- [ ] Store fact to unauthorized scope → verify rejection\n- [ ] Create entity → add relationship → query by entityId → verify\n- [ ] Create session → add conversation → link fact to conversation → verify chain\n- [ ] Record signal on fact → query signals by fact → verify\n- [ ] Create theme → add facts → query by scope → verify\n\n### Full-Text Search Tests\n- [ ] Search \"Cohere\" → returns fact about embeddings\n- [ ] Search \"Convex\" with factType filter → returns only matching type\n- [ ] Search with scopeId filter → returns only facts in that scope\n- [ ] Search with createdBy filter → returns only facts by that agent\n- [ ] Empty search → returns empty array (no crash)\n\n### Write Permission Tests\n- [ ] Agent in scope.members can write to scope with writePolicy: \"members\"\n- [ ] Agent NOT in scope.members is rejected for writePolicy: \"members\"\n- [ ] Any agent can write to scope with writePolicy: \"all\"\n- [ ] Only creator can write to scope with writePolicy: \"creator\"\n\n### Seed Script Verification\n- [ ] Run scripts/seed.ts → no errors\n- [ ] Run scripts/seed.ts AGAIN → no duplicates (idempotent)\n- [ ] Query entities → 7 entities with correct relationships\n- [ ] Query scopes → global and private-indy exist\n- [ ] Search facts → seed facts are searchable\n\n### TypeScript Quality\n- [ ] No any types in function args/returns\n- [ ] TypeScript strict mode enabled in convex/tsconfig.json\n- [ ] All Convex validators use v.* types\n\n## How to Test\n1. npx convex dev — verify compile\n2. npx tsx scripts/seed.ts — run seed\n3. Use Convex dashboard to inspect tables and run queries\n4. Alternatively, use convex CLI: npx convex run functions/facts:searchFacts '{\"query\": \"Cohere\"}'\n\n## Phase 1 Complete When\nALL of the above checks pass. This unblocks Phase 2 (MCP Server).\n\n## Estimate\n30 minutes","status":"open","priority":1,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:07:50.19959+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:07:50.19959+01:00","dependencies":[{"issue_id":"engram-u51.13","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:07:50.200464+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.4","type":"blocks","created_at":"2026-02-11T22:07:50.201628+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.5","type":"blocks","created_at":"2026-02-11T22:07:50.202672+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.6","type":"blocks","created_at":"2026-02-11T22:07:50.203805+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.7","type":"blocks","created_at":"2026-02-11T22:07:50.204824+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.8","type":"blocks","created_at":"2026-02-11T22:07:50.205908+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.9","type":"blocks","created_at":"2026-02-11T22:07:50.207039+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.10","type":"blocks","created_at":"2026-02-11T22:07:50.208045+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.11","type":"blocks","created_at":"2026-02-11T22:07:50.209063+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.13","depends_on_id":"engram-u51.12","type":"blocks","created_at":"2026-02-11T22:07:50.210063+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.2","title":"Define complete 10-table schema in convex/schema.ts","description":"# Define Complete 10-Table Schema\n\n## What\nCreate convex/schema.ts with ALL 10 tables from PLAN.md (lines 89-289), including all optional future-phase fields. This is the single most important file in Phase 1 — it defines the entire data model.\n\n## Why\nUsing the full PLAN.md schema from day 1 prevents costly migrations when later phases add lifecycle management, emotional context, temporal links, etc. Convex schema changes require explicit migrations. Optional fields (v.optional()) cost nothing until populated. Deploy once, never migrate schema.\n\n## Schema Decision: Full vs Simplified\nThe repo-research agent found 17 schema discrepancies between PLAN.md and the detailed plan. Key decisions:\n- Use lifecycleState (5 states: active|dormant|merged|archived|pruned), NOT status (3 states)\n- Include factualSummary (SimpleMem compressed representation)\n- Include updatedAt (needed for sync tracking in Phase 5)\n- Include outcomeScore (MemRL learned utility — Phase 4+)\n- Include contributingAgents (collaborative memory provenance — Phase 4+)\n- Include emotionalContext + emotionalWeight (GIZIN emotional memory — Phase 3+)\n- Include temporalLinks (MAGMA multi-graph pattern — Phase 3+)\n- Include forgetScore, mergedInto, consolidatedFrom, supersededBy (lifecycle — Phase 3+)\n- Include conversations.threadFacts (facts-to-conversations linking)\n- Include sessions.conversationIds (session-conversation links)\n- Include agents.telos (PAI purpose/goal)\n- Include memory_scopes.memoryPolicy + idealStateCriteria (ALMA + PAI)\n\n## Tables to Define\n\n### 1. facts (26 fields, 5 indexes + 1 searchIndex + 1 vectorIndex)\nThe core memory unit. Stores atomic facts with embeddings, importance scores, lifecycle state, emotional context, temporal links, and scope.\n- Core fields: content, timestamp, source, entityIds, relevanceScore, accessedCount, importanceScore, createdBy, scopeId, tags, factType, embedding\n- Lifecycle: lifecycleState, mergedInto, consolidatedFrom, supersededBy, forgetScore\n- Emotional: emotionalContext, emotionalWeight\n- Multi-graph: temporalLinks (array of {targetFactId, relation, confidence})\n- Research-informed: factualSummary, updatedAt, outcomeScore, contributingAgents\n- References: conversationId\n- Indexes: by_scope, by_agent, by_type, by_importance, by_lifecycle\n- searchIndex: search_content (field: content, filters: scopeId, factType, createdBy)\n- vectorIndex: vector_search (field: embedding, dimensions: 1024, filters: scopeId)\n\n### 2. entities (name, type, relationships graph, 4 indexes)\n### 3. conversations (sessionId, participants, threadFacts, handoffs, 2 indexes)\n### 4. sessions (agentId, conversationIds, factCount, 2 indexes)\n### 5. agents (agentId, name, capabilities, telos, settings, 1 index)\n### 6. memory_scopes (name, members, policies, ISC, 1 index)\n### 7. signals (factId, agentId, signalType, value, 3 indexes)\n### 8. themes (name, factIds, entityIds, scopeId, embedding, 2 indexes + 1 vectorIndex)\n### 9. sync_log (nodeId, lastSyncTimestamp, status, 1 index)\n\n## Critical Constraints\n- vectorIndex dimensions MUST be 1024 (Cohere Embed 4 output dimension)\n- vectorIndex filterFields only support equality filters via q.eq()\n- searchIndex filterFields support equality filters for pre-filtering\n- All future-phase fields must be v.optional()\n- factType is a string union: decision|observation|plan|error|insight|correction|steering_rule|learning|session_summary\n- lifecycleState string union: active|dormant|merged|archived|pruned\n\n## Source of Truth\nCopy schema definitions EXACTLY from PLAN.md lines 89-289. The schema in the detailed plan (docs/plans/2026-02-11-feat-engram-unified-memory-system-plan.md lines 93-242) is the SIMPLIFIED version — do NOT use it.\n\n## Acceptance Criteria\n- [ ] convex/schema.ts defines all 10 tables\n- [ ] facts table has all 26 fields (most as v.optional())\n- [ ] All indexes defined (5 regular + 1 search + 1 vector on facts, plus others)\n- [ ] vectorIndex dimensions set to 1024\n- [ ] npx convex dev compiles without schema errors\n- [ ] Convex dashboard shows all 10 tables with correct structure\n\n## Estimate\n45 minutes","status":"closed","priority":0,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:04:36.166167+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:05.787684+01:00","closed_at":"2026-02-11T22:25:05.787686+01:00","dependencies":[{"issue_id":"engram-u51.2","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:04:36.166973+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.2","depends_on_id":"engram-u51.1","type":"blocks","created_at":"2026-02-11T22:04:36.168035+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.3","title":"Implement memory_scopes CRUD with write policy enforcement","description":"# Implement Memory Scopes CRUD\n\n## What\nCreate convex/functions/scopes.ts with full CRUD operations for the memory_scopes table, including the critical checkWriteAccess helper used by storeFact. This task must be completed BEFORE facts CRUD because storeFact depends on scope write permission enforcement.\n\n## Why\nScopes are the access control mechanism for Engram. Every fact belongs to a scope. Scopes define who can read and write. The storeFact mutation must check scope writePolicy before inserting — this is a PLAN.md Phase 1 requirement that was missing from the detailed plan.\n\nScope types:\n- private-{agentId}: Only that agent can read/write\n- team-{name}: Team members can read/write\n- project-{name}: Project-scoped with member lists\n- global: Everyone can read/write (public knowledge base)\n\n## Functions to Implement\n\n### Mutations\n1. createScope(name, description, members, readPolicy, writePolicy, retentionDays?)\n   - Validate name uniqueness via by_name index\n   - Default readPolicy: \"members\", writePolicy: \"members\"\n   - Return scope ID\n\n2. addMember(scopeId, agentId)\n   - Append to members array if not already present\n   - idempotent\n\n3. removeMember(scopeId, agentId)\n   - Filter from members array\n   - Error if agent is last member (can't have empty scope)\n\n### Queries\n4. getScope(scopeId) — by Convex _id\n5. getScopeByName(name) — using by_name index\n6. getPermittedScopes(agentId) — return all scopes where agentId is in members OR readPolicy is \"all\"\n\n### Internal Helper (exported as internalQuery)\n7. checkWriteAccess(scopeId, agentId) — returns boolean\n   - If writePolicy === \"all\": return true\n   - If writePolicy === \"members\": return members.includes(agentId)\n   - If writePolicy === \"creator\": return members[0] === agentId (first member is creator)\n\n## Write Policy Logic\n| writePolicy | Who Can Write |\n|-------------|---------------|\n| \"all\" | Any agent |\n| \"members\" | Only agents in scope.members array |\n| \"creator\" | Only first member (scope creator) |\n\n## Technical Notes\n- Use Convex v validators for all args\n- Use shared helper pattern: export both public query and internalQuery versions\n- getPermittedScopes needs to check both membership AND readPolicy === \"all\"\n- For Phase 1, no auth beyond agent ID trust boundary\n\n## Acceptance Criteria\n- [ ] Can create a new scope with name, description, members, policies\n- [ ] Can add/remove members from a scope\n- [ ] getPermittedScopes returns correct scopes for an agent\n- [ ] checkWriteAccess correctly enforces writePolicy for \"all\", \"members\", \"creator\"\n- [ ] Duplicate scope names are rejected\n- [ ] Cannot remove last member from a scope\n\n## Estimate\n30 minutes","status":"closed","priority":1,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:04:55.227542+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:05.911549+01:00","closed_at":"2026-02-11T22:25:05.911551+01:00","dependencies":[{"issue_id":"engram-u51.3","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:04:55.228438+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.3","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:04:55.229555+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.4","title":"Implement facts CRUD with write permission and full-text search","description":"# Implement Facts CRUD with Write Permission \u0026 Full-Text Search\n\n## What\nCreate convex/functions/facts.ts — the most important function file. Implements storeFact (with scope write permission check), read queries, full-text search, and access tracking. This is the core memory primitive that all MCP tools will use.\n\n## Why\nFacts are the atomic memory units in Engram. Every memory_store_fact, memory_recall, memory_search MCP tool call ultimately hits these functions. Getting storeFact right is critical — it must enforce scope write permissions, estimate importance without external calls, and prepare for async enrichment (Phase 3).\n\n## Functions to Implement\n\n### Mutations\n\n1. storeFact — THE critical mutation\n   Args: content, source?, entityIds?, tags?, factType?, scopeId, createdBy, conversationId?, emotionalContext?\n   Logic:\n   a. Check write permission: call checkWriteAccess(scopeId, createdBy) — throw if unauthorized\n   b. Estimate importance: keyword-based scoring (no external calls)\n      - High (0.9): decision, error, critical, breaking, failed, security\n      - Medium (0.6): fix, implement, create, build, update, deploy\n      - Low (0.3): note, observation, maybe, consider, minor\n      - Default: 0.5\n   c. Insert fact with defaults: relevanceScore=1.0, accessedCount=0, lifecycleState=\"active\", embedding=undefined\n   d. Comment out enrichment scheduler: // await ctx.scheduler.runAfter(0, internal.actions.enrich.enrichFact, { factId })\n   e. Return { factId, importanceScore }\n\n2. bumpAccess(factId)\n   - Increment accessedCount by 1\n   - Recalculate relevanceScore (simple: min(1.0, 0.5 + accessedCount * 0.05))\n\n3. updateEnrichment(factId, updates) — internalMutation\n   - Patch fact with embedding, factualSummary, entityIds, temporalLinks, etc.\n   - Set updatedAt to Date.now()\n   - Used by Phase 3 enrichment pipeline\n\n### Queries\n\n4. getFact(factId) — query by Convex _id\n5. getByIds(factIds: Id\u003c\"facts\"\u003e[]) — query multiple facts\n6. getByScope(scopeId, limit?, factType?) — using by_scope index\n7. getByAgent(createdBy, limit?) — using by_agent index\n\n### Full-Text Search\n\n8. searchFacts(query, scopeId?, factType?, createdBy?, limit?)\n   - Uses searchIndex(\"search_content\")\n   - Filter by scopeId, factType, createdBy (all optional)\n   - Default limit: 10\n   - Returns matching facts sorted by relevance\n\n## storeFact Implementation Pattern (from detailed plan lines 269-308)\n\n```typescript\nexport const storeFact = mutation({\n  args: {\n    content: v.string(),\n    source: v.optional(v.string()),\n    entityIds: v.optional(v.array(v.string())),\n    tags: v.optional(v.array(v.string())),\n    factType: v.optional(v.string()),\n    scopeId: v.id(\"memory_scopes\"),\n    createdBy: v.string(),\n    conversationId: v.optional(v.id(\"conversations\")),\n    emotionalContext: v.optional(v.string()),\n  },\n  returns: v.object({ factId: v.id(\"facts\"), importanceScore: v.number() }),\n  handler: async (ctx, args) =\u003e {\n    // 1. Check write permission\n    const scope = await ctx.db.get(args.scopeId);\n    if (!scope) throw new Error(\"Scope not found\");\n    if (scope.writePolicy === \"members\" \u0026\u0026 !scope.members.includes(args.createdBy)) {\n      throw new Error(\"Agent not authorized to write to this scope\");\n    }\n    // ... (see Phase 1 plan for full implementation)\n  },\n});\n```\n\n## Full-Text Search Pattern\n\n```typescript\nexport const searchFacts = query({\n  args: {\n    query: v.string(),\n    scopeId: v.optional(v.id(\"memory_scopes\")),\n    factType: v.optional(v.string()),\n    createdBy: v.optional(v.string()),\n    limit: v.optional(v.number()),\n  },\n  handler: async (ctx, args) =\u003e {\n    let search = ctx.db.query(\"facts\").withSearchIndex(\"search_content\", (q) =\u003e {\n      let s = q.search(\"content\", args.query);\n      if (args.scopeId) s = s.eq(\"scopeId\", args.scopeId);\n      if (args.factType) s = s.eq(\"factType\", args.factType);\n      if (args.createdBy) s = s.eq(\"createdBy\", args.createdBy);\n      return s;\n    });\n    return await search.take(args.limit ?? 10);\n  },\n});\n```\n\n## Critical Constraints\n- Mutations retry automatically on transient errors — make storeFact idempotent-safe\n- Don't use console.log (reserved for MCP stdio in Phase 2) — use console.error for debugging\n- The enrichment scheduler call should be COMMENTED OUT in Phase 1 (action doesn't exist yet)\n- Use shared helper pattern for getFact (public query + internalQuery)\n- estimateImportance is a plain function, not a Convex function (no ctx needed)\n\n## Acceptance Criteria\n- [ ] storeFact mutation works with scope write permission check\n- [ ] storeFact rejects unauthorized writes (writePolicy: \"members\" with non-member)\n- [ ] getFact and getByIds return correct facts\n- [ ] searchFacts returns full-text search results with scope/type/agent filtering\n- [ ] bumpAccess increments count and updates relevanceScore\n- [ ] updateEnrichment (internal) can patch fact with enrichment data\n- [ ] estimateImportance returns correct scores for high/medium/low keywords\n\n## Estimate\n60 minutes","status":"closed","priority":0,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:05:26.070928+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:06.042923+01:00","closed_at":"2026-02-11T22:25:06.042925+01:00","dependencies":[{"issue_id":"engram-u51.4","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:05:26.071768+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.4","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:05:26.072955+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.4","depends_on_id":"engram-u51.3","type":"blocks","created_at":"2026-02-11T22:05:26.073956+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.5","title":"Implement entities CRUD with relationship graph","description":"# Implement Entities CRUD\n\n## What\nCreate convex/functions/entities.ts with CRUD operations for the entities table. Entities are named concepts (person, project, company, concept, tool) with a relationship graph.\n\n## Why\nEntities are the knowledge graph nodes in Engram. They represent people (Ryan, Indy), projects (OpenClaw, Engram), tools (Convex, LanceDB, Cohere), etc. Facts link to entities via entityIds array. The entity extraction pipeline (Phase 3) will auto-create entities from fact content.\n\n## Entity Schema (from PLAN.md)\n- entityId: string — human-readable ID like \"entity-ryan\", \"entity-convex\"\n- name: string — display name\n- type: string — person|project|company|concept|tool\n- firstSeen, lastSeen: number — timestamps\n- metadata: v.any() — flexible key-value store\n- relationships: array of {targetId, relationType, since?}\n  - Relation types: created_by|depends_on|works_with|part_of|related_to\n- importanceScore: float64\n- accessCount: number\n- createdBy: string — agent ID\n\n## Functions to Implement\n\n### Mutations\n1. upsert(entityId, name, type, metadata?, createdBy)\n   - Check if entity exists via by_entity_id index\n   - If exists: update lastSeen, merge metadata, increment accessCount\n   - If new: create with firstSeen=lastSeen=Date.now(), accessCount=1, relationships=[], importanceScore=0.5\n\n2. addRelationship(entityId, targetId, relationType, since?)\n   - Find entity via by_entity_id index\n   - Check for duplicate relationship (same targetId + relationType)\n   - Append to relationships array if new\n\n3. updateImportance(entityId, importanceScore) — internalMutation for Phase 3\n\n### Queries\n4. get(entityConvexId) — by Convex _id\n5. getByEntityId(entityId) — using by_entity_id index\n6. getByType(type, limit?) — using by_type index\n7. searchEntities(query, limit?) — full-text search on entity name\n\n## Technical Notes\n- entityId is the human-readable string (e.g., \"entity-ryan\"), NOT the Convex _id\n- The by_entity_id index enables O(1) lookup by string ID\n- metadata is v.any() for flexibility — stores arbitrary key-value data\n- Relationships form a directed graph: entity A relates_to entity B\n- The seed script will create initial entities using upsert\n\n## Acceptance Criteria\n- [ ] Can create new entity via upsert\n- [ ] Upsert on existing entity updates lastSeen and increments accessCount\n- [ ] Can add relationships between entities\n- [ ] Duplicate relationships are ignored (idempotent)\n- [ ] getByEntityId returns correct entity\n- [ ] searchEntities uses full-text search index on name field\n\n## Estimate\n30 minutes","status":"closed","priority":1,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:05:44.180853+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:06.177017+01:00","closed_at":"2026-02-11T22:25:06.177019+01:00","dependencies":[{"issue_id":"engram-u51.5","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:05:44.181937+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.5","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:05:44.183246+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.6","title":"Implement agents CRUD with registration","description":"# Implement Agents CRUD\n\n## What\nCreate convex/functions/agents.ts with CRUD operations for the agents table. Agents are the identities that interact with Engram memory.\n\n## Why\nEvery memory operation is attributed to an agent. Agent registration is the first step when an agent connects to Engram. The agents table tracks capabilities, last seen time, fact count, default scope, and optional telos (purpose/goal from PAI pattern).\n\n## Agent Schema (from PLAN.md)\n- agentId: string — human-readable like \"indy\", \"coder-1\", \"ml-worker\"\n- name: string — display name\n- nodeId: string? — OpenClaw node identifier\n- capabilities: string[] — what the agent can do\n- lastSeen: number — timestamp of last activity\n- factCount: number — total facts created by this agent\n- defaultScope: string — \"private\"|\"team\"|\"public\"\n- telos: string? — purpose/goal (PAI pattern, e.g., \"Ship code faster\")\n- settings: any? — agent-specific memory configuration\n\n## Functions to Implement\n\n### Mutations\n1. register(agentId, name, capabilities, defaultScope, nodeId?, telos?, settings?)\n   - Check if agent exists via by_agent_id index\n   - If exists: update lastSeen, capabilities, nodeId, telos, settings\n   - If new: create with lastSeen=Date.now(), factCount=0\n   - Also create private scope \"private-{agentId}\" if not exists\n   - Return agent Convex _id\n\n2. updateLastSeen(agentId) — called on every agent interaction\n   - Update lastSeen to Date.now()\n\n3. incrementFactCount(agentId) — internalMutation\n   - Increment factCount by 1 (called by storeFact)\n\n### Queries\n4. get(agentConvexId) — by Convex _id\n5. getByAgentId(agentId) — using by_agent_id index\n6. listAgents(limit?) — list all agents ordered by lastSeen\n\n## Technical Notes\n- Agent registration should be idempotent (re-registering updates, doesn't create duplicate)\n- The register mutation should also create the agent's private scope (depends on scopes CRUD existing, but can be done inline)\n- factCount is denormalized for quick access — incremented by storeFact\n- defaultScope determines where facts go when scopeId is not explicitly provided\n\n## Acceptance Criteria\n- [ ] Can register a new agent with capabilities and telos\n- [ ] Re-registration updates existing agent (idempotent)\n- [ ] updateLastSeen correctly timestamps\n- [ ] getByAgentId returns correct agent via index\n- [ ] listAgents returns agents sorted by lastSeen\n\n## Estimate\n25 minutes","status":"closed","priority":1,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:06:00.876537+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:06.309545+01:00","closed_at":"2026-02-11T22:25:06.309547+01:00","dependencies":[{"issue_id":"engram-u51.6","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:06:00.878563+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.6","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:06:00.88125+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.7","title":"Implement conversations CRUD with handoff tracking","description":"# Implement Conversations CRUD\n\n## What\nCreate convex/functions/conversations.ts for the conversations table. Conversations thread facts together, track participants, and record agent handoffs.\n\n## Why\nConversations provide temporal grouping of facts within a session. They track which agents participated and when handoffs occurred (Agent A passes context to Agent B). The threadFacts array links facts to their conversation for retrieval.\n\n## Schema (from PLAN.md)\n- sessionId: Id\u003c\"sessions\"\u003e\n- participants: string[] (agent IDs)\n- threadFacts: Id\u003c\"facts\"\u003e[] (linked facts)\n- contextSummary: string\n- importance: float64\n- tags: string[]\n- handoffs: array of {fromAgent, toAgent, timestamp, contextSummary}\n\n## Functions to Implement\n\n### Mutations\n1. create(sessionId, participants, contextSummary?, tags?) — create new conversation\n2. addFact(conversationId, factId) — append to threadFacts array\n3. addHandoff(conversationId, fromAgent, toAgent, contextSummary) — record agent handoff\n4. updateSummary(conversationId, contextSummary) — update context summary\n\n### Queries\n5. get(conversationId) — by Convex _id\n6. getBySession(sessionId) — using by_session index\n\n## Conversation Boundary Logic (from SpecFlow analysis)\n- Time gap \u003e 30 minutes OR agent explicitly calls boundary → new conversation\n- This logic lives in the MCP server (Phase 2), not in Convex functions\n\n## Acceptance Criteria\n- [ ] Can create conversations linked to sessions\n- [ ] Can add facts to conversation threadFacts\n- [ ] Can record handoffs between agents\n- [ ] getBySession returns conversations for a session\n\n## Estimate\n20 minutes","status":"closed","priority":2,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:06:14.540067+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:07.17318+01:00","closed_at":"2026-02-11T22:25:07.173182+01:00","dependencies":[{"issue_id":"engram-u51.7","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:06:14.541431+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.7","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:06:14.542843+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.8","title":"Implement sessions CRUD","description":"# Implement Sessions CRUD\n\n## What\nCreate convex/functions/sessions.ts for the sessions table. Sessions track agent activity periods.\n\n## Schema (from PLAN.md)\n- agentId: string\n- startTime: number\n- lastActivity: number\n- conversationIds: Id\u003c\"conversations\"\u003e[]\n- factCount: number\n- contextSummary: string\n- parentSession: Id\u003c\"sessions\"\u003e? (for nested/resumed sessions)\n- nodeId: string? (OpenClaw node)\n\n## Functions to Implement\n\n### Mutations\n1. create(agentId, contextSummary?, parentSession?, nodeId?) — start new session\n2. updateActivity(sessionId) — update lastActivity timestamp\n3. addConversation(sessionId, conversationId) — append to conversationIds\n4. incrementFactCount(sessionId) — internalMutation\n\n### Queries\n5. get(sessionId)\n6. getByAgent(agentId, limit?) — using by_agent index, ordered by startTime\n7. getActive(agentId) — most recent session for an agent\n\n## Acceptance Criteria\n- [ ] Can create sessions linked to agents\n- [ ] updateActivity correctly timestamps\n- [ ] getByAgent returns sessions ordered by startTime\n- [ ] getActive returns the most recent session\n\n## Estimate\n20 minutes","status":"closed","priority":2,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:06:26.582497+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:07.321437+01:00","closed_at":"2026-02-11T22:25:07.32144+01:00","dependencies":[{"issue_id":"engram-u51.8","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:06:26.583468+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.8","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:06:26.584755+01:00","created_by":"Ryan Lisse"}]}
{"id":"engram-u51.9","title":"Implement signals CRUD for feedback tracking","description":"# Implement Signals CRUD\n\n## What\nCreate convex/functions/signals.ts for the signals table. Signals capture feedback on facts — explicit ratings and implicit sentiment from the PAI feedback loop pattern.\n\n## Why\nSignals are how agents communicate which memories were useful. This enables learned utility scoring (MemRL pattern) in later phases. The PAI system uses explicit ratings (1-10) and implicit sentiment (-1.0 to 1.0) to steer memory retrieval.\n\n## Schema (from PLAN.md)\n- factId: Id\u003c\"facts\"\u003e? (optional — some signals are session-level)\n- sessionId: Id\u003c\"sessions\"\u003e? (optional)\n- agentId: string\n- signalType: string — explicit_rating|implicit_sentiment|failure\n- value: number — 1-10 for ratings, -1.0 to 1.0 for sentiment\n- comment: string?\n- confidence: float64?\n- context: string?\n- timestamp: number\n\n## Functions to Implement\n\n### Mutations\n1. recordSignal(factId?, sessionId?, agentId, signalType, value, comment?, confidence?, context?)\n   - Validate: at least one of factId or sessionId must be provided\n   - Validate: value range depends on signalType (1-10 for rating, -1.0-1.0 for sentiment)\n   - Set timestamp to Date.now()\n\n### Queries\n2. getByFact(factId, limit?) — using by_fact index\n3. getByAgent(agentId, limit?) — using by_agent index\n4. getByType(signalType, limit?) — using by_type index\n\n## Acceptance Criteria\n- [ ] Can record signals with fact or session reference\n- [ ] Validation rejects signals without factId AND sessionId\n- [ ] getByFact returns signals for a specific fact\n- [ ] getByAgent returns signals from a specific agent\n\n## Estimate\n20 minutes","status":"closed","priority":2,"issue_type":"task","owner":"ryan@ryanlisse.com","created_at":"2026-02-11T22:06:39.616471+01:00","created_by":"Ryan Lisse","updated_at":"2026-02-11T22:25:07.467715+01:00","closed_at":"2026-02-11T22:25:07.467719+01:00","dependencies":[{"issue_id":"engram-u51.9","depends_on_id":"engram-u51","type":"parent-child","created_at":"2026-02-11T22:06:39.617434+01:00","created_by":"Ryan Lisse"},{"issue_id":"engram-u51.9","depends_on_id":"engram-u51.2","type":"blocks","created_at":"2026-02-11T22:06:39.618846+01:00","created_by":"Ryan Lisse"}]}
